#!/usr/bin/env bash
# pmemtester - Parallel wrapper for memtester
# Version: 0.2
# Author: Johnathon Weare <jrweare@gmail.com>
# URL: https://github.com/widefox/pmemtester
# SPDX-License-Identifier: GPL-2.0-only

set -euo pipefail

# shellcheck disable=SC2034
pmemtester_version="0.2"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/dev/null
for lib in "${SCRIPT_DIR}"/lib/*.sh; do
    source "$lib"
done

main() {
    parse_args "$@"
    validate_args
    color_init

    local memtester_path
    memtester_path="$(find_memtester "$MEMTESTER_DIR")"
    validate_memtester "$memtester_path"

    # Resolve stressapptest binary based on mode
    local stressapptest_path=""
    local run_stressapptest_pass=0
    case "$STRESSAPPTEST_MODE" in
        on)
            stressapptest_path="$(find_stressapptest "$STRESSAPPTEST_DIR")"
            validate_stressapptest "$stressapptest_path"
            run_stressapptest_pass=1
            ;;
        auto)
            if stressapptest_path="$(find_stressapptest "$STRESSAPPTEST_DIR" 2>/dev/null)"; then
                run_stressapptest_pass=1
            fi
            ;;
        off)
            run_stressapptest_pass=0
            ;;
    esac

    local ram_kb core_count ram_per_core_mb
    ram_kb="$(calculate_test_ram_kb "$PERCENT" "$RAM_TYPE")"
    core_count="$(get_core_count)"
    ram_per_core_mb="$(divide_ram_per_core_mb "$ram_kb" "$core_count")"
    validate_ram_params "$PERCENT" "$core_count" "$ram_per_core_mb"

    local size_arg
    size_arg="$(mb_to_memtester_arg "$ram_per_core_mb")"

    check_memlock_sufficient "$ram_kb" || configure_memlock "$ram_kb"

    local log_dir="${LOG_DIR:-/tmp/pmemtester.$$}"
    init_logs "$log_dir" "$core_count"

    log_master "Starting pmemtester: ${ram_per_core_mb}MB x ${core_count} cores" "$log_dir"

    # EDAC before
    local edac_supported=0
    if check_edac_supported 2>/dev/null; then
        edac_supported=1
        capture_edac_messages > "${log_dir}/edac_messages_before.txt"
        capture_edac_counters > "${log_dir}/edac_counters_before.txt"
    fi

    # Run memtesters
    local memtester_start_seconds=$SECONDS
    run_all_memtesters "$memtester_path" "$size_arg" "$ITERATIONS" "$core_count" "$log_dir"
    local memtester_result=0
    wait_and_collect "$log_dir" || memtester_result=1
    local memtester_elapsed=$(( SECONDS - memtester_start_seconds ))

    # Conditional stressapptest execution
    local stressapptest_result=0
    if [[ "$run_stressapptest_pass" -eq 1 ]]; then
        # auto mode: skip if memtester failed
        if [[ "$STRESSAPPTEST_MODE" == "auto" ]] && [[ "$memtester_result" -ne 0 ]]; then
            log_master "Skipping stressapptest: memtester failed" "$log_dir"
        else
            # Determine duration
            local sat_seconds="$STRESSAPPTEST_SECONDS"
            if [[ "$sat_seconds" -eq 0 ]]; then
                sat_seconds="$memtester_elapsed"
                if [[ "$sat_seconds" -lt 1 ]]; then
                    sat_seconds=1
                fi
            fi
            # Total MB across all cores
            local total_mb=$(( ram_per_core_mb * core_count ))
            run_stressapptest "$stressapptest_path" "$sat_seconds" "$total_mb" "$core_count" "$log_dir" || stressapptest_result=1
        fi
    fi

    # EDAC after (spans both passes)
    local edac_msg_result=0
    local edac_class="none"
    if [[ "$edac_supported" -eq 1 ]]; then
        capture_edac_messages > "${log_dir}/edac_messages_after.txt"
        capture_edac_counters > "${log_dir}/edac_counters_after.txt"
        compare_edac_messages "${log_dir}/edac_messages_before.txt" "${log_dir}/edac_messages_after.txt" || edac_msg_result=1
        edac_class="$(classify_edac_counters "${log_dir}/edac_counters_before.txt" "${log_dir}/edac_counters_after.txt" 2>"${log_dir}/edac_detail.txt")" || true
        if [[ "$edac_class" != "none" ]]; then
            log_master "EDAC counter classification: ${edac_class}" "$log_dir"
            cat "${log_dir}/edac_detail.txt" >> "${log_dir}/master.log"
        fi
    fi

    aggregate_logs "$log_dir" "$core_count"

    # Final verdict
    # Build failure source for diagnostic output
    local fail_sources=""
    if [[ "$memtester_result" -ne 0 ]]; then
        fail_sources="memtester"
    fi
    if [[ "$stressapptest_result" -ne 0 ]]; then
        fail_sources="${fail_sources:+${fail_sources}, }stressapptest"
    fi
    if [[ "$edac_class" == "ue_only" ]] || [[ "$edac_class" == "ce_and_ue" ]]; then
        fail_sources="${fail_sources:+${fail_sources}, }EDAC: ${edac_class}"
    fi
    if [[ "$edac_msg_result" -ne 0 ]]; then
        fail_sources="${fail_sources:+${fail_sources}, }EDAC: new messages"
    fi

    # Priority 1: any failure → FAIL
    if [[ -n "$fail_sources" ]]; then
        log_master "FAIL: memtester_result=${memtester_result} stressapptest_result=${stressapptest_result} edac_class=${edac_class} edac_msg_result=${edac_msg_result}" "$log_dir"
        color_fail "$fail_sources"
        return 1
    fi
    # Priority 2: CE only + --allow-ce → PASS with WARNING
    if [[ "$edac_class" == "ce_only" ]] && [[ "$ALLOW_CE" -eq 1 ]]; then
        log_master "PASS (WARNING: correctable EDAC errors detected)" "$log_dir"
        color_pass
        color_warn "correctable EDAC errors detected (ce_only)"
        return 0
    fi
    # Priority 3: CE only without --allow-ce → FAIL
    if [[ "$edac_class" == "ce_only" ]]; then
        log_master "FAIL: memtester_result=${memtester_result} edac_class=${edac_class}" "$log_dir"
        color_fail "EDAC: ce_only"
        return 1
    fi
    # Priority 4: clean → PASS
    log_master "PASS: All tests passed, no EDAC errors" "$log_dir"
    color_pass
    return 0
}

main "$@"
